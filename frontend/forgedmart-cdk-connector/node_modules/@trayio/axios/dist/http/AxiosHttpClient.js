"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxiosHttpClient = void 0;
const TE = __importStar(require("fp-ts/TaskEither"));
const function_1 = require("fp-ts/function");
const Http_1 = require("@trayio/commons/http/Http");
const Task_1 = require("@trayio/commons/task/Task");
const axios_1 = __importDefault(require("axios"));
const FormData = require("form-data");
const NodeFsFileStorage_1 = require("@trayio/commons/file/NodeFsFileStorage");
const BufferExtensions_1 = require("@trayio/commons/buffer/BufferExtensions");
class AxiosHttpClient {
    constructor(fileStorage = new NodeFsFileStorage_1.NodeFsFileStorage()) {
        this.fileStorage = fileStorage;
        this.appendFields = (formData) => (fields) => {
            Object.entries(fields).forEach(([key, value]) => {
                formData.append(key, value);
            });
            return formData;
        };
    }
    execute(method, url, request) {
        /*
          Removes default headers so that we control what we send to the server, without this, it sends default content-type and accept headers,
          the caller of this HttpClient interface is responsible of deciding the values of these headers, axios shouldn't try to be smart
          and derive these from the body or even set defaults.
        */
        axios_1.default.defaults.headers.common = {};
        axios_1.default.defaults.headers.get = {};
        axios_1.default.defaults.headers.post = {};
        axios_1.default.defaults.headers.put = {};
        axios_1.default.defaults.headers.patch = {};
        axios_1.default.defaults.headers.delete = {};
        const finalUrl = Object.entries(request.pathParams).reduce((acc, [key, value]) => acc.replace(`:${key}`, encodeURIComponent(value)), url);
        const headers = Object.entries(request.headers).reduce((acc, [key, value]) => {
            const newValue = typeof value === 'string' ? value : value.join(', ');
            return Object.assign(Object.assign({}, acc), { [key]: newValue });
        }, {});
        let axiosConfig;
        if (headers['content-type'] &&
            headers['content-type'].includes(Http_1.HttpContentType.MultipartRequestBody)) {
            const formData = new FormData();
            this.appendFields(formData)(request.body.fields);
            const fileEntries = Object.entries(request.body.files);
            const taskEithers = fileEntries.map(([key, value]) => { var _a; return this.fileStorage.read(value.key, (_a = value.metadata.name) !== null && _a !== void 0 ? _a : key); });
            return (0, function_1.pipe)(TE.sequenceArray(taskEithers), TE.chain((files) => {
                files.forEach((file) => {
                    formData.append(file.metadata.name, file.content, file.key);
                });
                axiosConfig = {
                    url: finalUrl,
                    method: method.toString(),
                    data: formData,
                    responseType: 'stream',
                    headers,
                    params: request.queryString,
                };
                return (0, Task_1.createTaskEitherFromPromiseWithSimpleError)(() => (0, axios_1.default)(axiosConfig)
                    .then(this.axiosResponseToHttpResponse)
                    .catch(this.axiosErrorToHttpResponse.bind(this)));
            }));
        }
        axiosConfig = {
            url: finalUrl,
            method: method.toString(),
            data: request.body,
            responseType: 'stream',
            headers,
            params: request.queryString,
        };
        return (0, Task_1.createTaskEitherFromPromiseWithSimpleError)(() => (0, axios_1.default)(axiosConfig)
            .then(this.axiosResponseToHttpResponse)
            .catch(this.axiosErrorToHttpResponse.bind(this)));
    }
    axiosErrorToHttpResponse(axiosError) {
        if (axiosError.response !== undefined) {
            return this.axiosResponseToHttpResponse(axiosError.response);
        }
        return {
            headers: {},
            statusCode: 500,
            body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
        };
    }
    axiosResponseToHttpResponse(axiosResponse) {
        return {
            headers: axiosResponse.headers,
            statusCode: axiosResponse.status,
            body: axiosResponse.data,
        };
    }
}
exports.AxiosHttpClient = AxiosHttpClient;
