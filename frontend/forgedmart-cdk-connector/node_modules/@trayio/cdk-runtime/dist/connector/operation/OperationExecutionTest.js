"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationExecutionTest = void 0;
const WinstonCliLogging_1 = require("@trayio/winston/cli/WinstonCliLogging");
const CliLogging_1 = require("@trayio/commons/cli/CliLogging");
// TODO move this to commons, newer versions of jest removed the "fail" method but left it in the types package.
function fail(reason) {
    throw new Error(reason);
}
global.fail = fail;
class OperationExecutionTest {
    constructor(handlerTest, handlerInvocationFactory) {
        this.handlerTest = handlerTest;
        this.handlerInvocationFactory = handlerInvocationFactory;
    }
    test(execution) {
        describe(`Operation ${this.handlerTest.handlerReference.name} Test`, () => {
            const defaultCtx = this.handlerTest.ctx;
            const defaultInvoke = this.handlerInvocationFactory(defaultCtx);
            let testContext;
            beforeAll(() => __awaiter(this, void 0, void 0, function* () {
                const beforeAllResult = yield this.handlerTest.beforeAllFunction(defaultCtx, defaultInvoke);
                switch (beforeAllResult.isSuccess) {
                    case false:
                        fail(`BeforeAll has failed with the following error ${beforeAllResult.error}`);
                    case true:
                        testContext = beforeAllResult.value;
                }
            }));
            this.handlerTest.testCaseFactories.forEach((testCaseFactory) => {
                it(testCaseFactory.description, () => __awaiter(this, void 0, void 0, function* () {
                    const testCase = testCaseFactory.testCase(testContext);
                    const { ctx } = testCase;
                    const invoke = this.handlerInvocationFactory(ctx);
                    const givenResult = yield testCase.givenFunction(ctx, testContext, invoke);
                    let testCaseContext;
                    switch (givenResult.isSuccess) {
                        case false:
                            fail(`Given has failed with the following error ${givenResult.error}`);
                        case true:
                            testCaseContext = givenResult.value;
                    }
                    const input = testCase.whenFunction(ctx, testContext, testCaseContext);
                    const output = yield execution.execute(ctx, input);
                    const infoArg = process.argv.filter((arg) => arg.startsWith('--verbose'))[0];
                    if (infoArg === '--verbose=true') {
                        const logger = new WinstonCliLogging_1.WinstonCliLogging();
                        logger.logBlock('Operation input', CliLogging_1.CliColors.blue);
                        logger.log(input);
                        if (!output.isFailure) {
                            const logOutput = output;
                            logger.logBlock('Operation output', CliLogging_1.CliColors.blue);
                            logger.log(logOutput.value);
                        }
                    }
                    const testCaseResult = {
                        ctx,
                        testContext,
                        testCaseContext,
                        input,
                        output,
                    };
                    testCase.thenFunction(testCaseResult);
                    const finallyResult = yield testCase.finallyFunction(testCaseResult, invoke);
                    if (finallyResult.isFailure) {
                        fail(`Finally has failed with the following error ${finallyResult.error}`);
                    }
                }));
            });
            afterAll(() => __awaiter(this, void 0, void 0, function* () {
                const afterAllResult = yield this.handlerTest.afterAllFunction(defaultCtx, testContext, defaultInvoke);
                if (afterAllResult.isFailure) {
                    fail(`AfterAll has failed with the following error ${afterAllResult.error}`);
                }
            }));
        });
    }
}
exports.OperationExecutionTest = OperationExecutionTest;
