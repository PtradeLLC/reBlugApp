"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpOperationExecution = void 0;
const OperationHandler_1 = require("@trayio/cdk-dsl/connector/operation/OperationHandler");
const HttpOperationHandler_1 = require("@trayio/cdk-dsl/connector/operation/HttpOperationHandler");
const Http_1 = require("@trayio/commons/http/Http");
const uuid_1 = require("uuid");
const JsonSerialization_1 = require("@trayio/commons/serialization/JsonSerialization");
const TE = __importStar(require("fp-ts/TaskEither"));
const E = __importStar(require("fp-ts/Either"));
const O = __importStar(require("fp-ts/Option"));
const function_1 = require("fp-ts/function");
const BufferExtensions_1 = require("@trayio/commons/buffer/BufferExtensions");
const mime = require('mime');
class HttpOperationExecution {
    constructor(httpClient, fileStorage, handler) {
        this.jsonSerialization = new JsonSerialization_1.JsonSerialization();
        this.httpClient = httpClient;
        this.fileStorage = fileStorage;
        this.handler = handler;
    }
    execute(ctx, input) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationRequest = this.handler.requestHandler(ctx, input, this.handler.request);
            const httpRequestE = yield this.operationRequestToHttpRequest(operationRequest)();
            if (E.isLeft(httpRequestE)) {
                return OperationHandler_1.OperationHandlerResult.failure(OperationHandler_1.OperationHandlerError.connectorError(httpRequestE.left.message));
            }
            const resultTE = this.httpClient.execute(operationRequest.method, operationRequest.path, httpRequestE.right);
            const operationResponseTE = (0, function_1.pipe)(resultTE, 
            // get the dsl http response object
            TE.map((response) => this.handler.responseHandler(ctx, input, new HttpOperationHandler_1.HttpOperationResponseBuilder(response, this.defaultErrorHandling(response.statusCode)))), 
            // interpret the dsl response object by mapping the low level http response to a connector response
            TE.chain((operationResponse) => this.parseResponse(operationResponse)), 
            // handle errors during the execution of the http request or parsing or the http response
            TE.mapLeft((error) => OperationHandler_1.OperationHandlerResult.failure(OperationHandler_1.OperationHandlerError.connectorError(error.message))));
            return TE.toUnion(operationResponseTE)();
        });
    }
    operationRequestToHttpRequest(operationRequest) {
        return (0, function_1.pipe)(operationRequest.contentType, O.map((contentType) => {
            switch (contentType) {
                case Http_1.HttpContentType.Json:
                    return this.serializeAsJson(operationRequest.body);
                case Http_1.HttpContentType.OctetStream:
                    return this.serializeAsFile(operationRequest);
                case Http_1.HttpContentType.MultipartRequestBody:
                    return this.serializeAsMultipart(operationRequest.body);
                case Http_1.HttpContentType.Text:
                    return this.serializeAsText(operationRequest.body);
                default:
                    return this.serializeAsJson(operationRequest.body);
            }
        }), O.getOrElse(() => this.serializeEmptyBody()), TE.map((serializedBody) => (Object.assign(Object.assign({}, operationRequest.request), { body: serializedBody }))));
    }
    serializeAsJson(body) {
        const serializedBody = this.jsonSerialization.serialize(body);
        return TE.right(BufferExtensions_1.BufferExtensions.arrayBufferToReadable(serializedBody));
    }
    serializeAsText(body) {
        const serializedBody = new TextEncoder().encode(body);
        return TE.right(BufferExtensions_1.BufferExtensions.arrayBufferToReadable(serializedBody));
    }
    serializeAsMultipart(body) {
        throw new Error('unimplemented');
    }
    serializeAsFile(operationRequest) {
        const downloadFilefromReference = this.httpClient.execute(Http_1.HttpMethod.Get, operationRequest.body.url, {
            headers: { [Http_1.HttpHeader.ContentType]: Http_1.HttpContentType.OctetStream },
            pathParams: {},
            queryString: {},
            body: BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)),
        });
        return (0, function_1.pipe)(downloadFilefromReference, TE.chain((response) => {
            if (response.statusCode >= 300) {
                return TE.left(Error('error downloading file from source'));
            }
            return TE.right(response.body);
        }));
    }
    serializeEmptyBody() {
        return TE.right(BufferExtensions_1.BufferExtensions.arrayBufferToReadable(new ArrayBuffer(0)));
    }
    defaultErrorHandling(statusCode) {
        return () => OperationHandler_1.OperationHandlerResult.failure(OperationHandler_1.OperationHandlerError.apiError(`API returned a status code of ${statusCode}`, {
            statusCode,
        }));
    }
    parseResponse(operationResponse) {
        if (operationResponse.response.statusCode >= 300) {
            return TE.right(operationResponse.errorHandling());
        }
        return (0, function_1.pipe)(operationResponse.contentType, O.map((contentType) => {
            switch (contentType) {
                case Http_1.HttpContentType.Json:
                    return this.parseBodyAsJson(operationResponse);
                case Http_1.HttpContentType.OctetStream:
                    return this.parseBodyAsFile(operationResponse);
                case Http_1.HttpContentType.MultipartRequestBody:
                    return TE.right(OperationHandler_1.OperationHandlerResult.failure(OperationHandler_1.OperationHandlerError.connectorError(`Invalid Response Type ${contentType}`)));
                case Http_1.HttpContentType.Text:
                    return this.parseeBodyAsText(operationResponse);
                default:
                    return this.parseBodyAsJson(operationResponse);
            }
        }), O.getOrElse(() => this.parseEmptyBody(operationResponse)));
    }
    parseBodyAsJson(operationResponse) {
        const bufferTE = BufferExtensions_1.BufferExtensions.readableToArrayBuffer(operationResponse.response.body);
        return (0, function_1.pipe)(bufferTE, TE.chain((buffer) => {
            const deserializedBodyE = this.jsonSerialization.deserialize(buffer);
            return TE.fromEither(deserializedBodyE);
        }), TE.map((deserializedBody) => operationResponse.responseParser(deserializedBody)));
    }
    parseEmptyBody(operationResponse) {
        return TE.right(operationResponse.responseParser(undefined));
    }
    parseBodyAsFile(operationResponse) {
        var _a;
        const contentType = (operationResponse.response.headers[Http_1.HttpHeader.ContentType.toLowerCase()]);
        const fileExtension = mime.getExtension(contentType);
        return (0, function_1.pipe)(this.fileStorage.write({
            content: operationResponse.response.body,
            key: fileExtension ? `${(0, uuid_1.v4)()}.${fileExtension}` : (0, uuid_1.v4)(),
            metadata: {
                name: (0, uuid_1.v4)(),
                size: parseFloat((_a = (operationResponse.response.headers[Http_1.HttpHeader.ContentLength.toLowerCase()])) !== null && _a !== void 0 ? _a : undefined),
                contentType,
            },
        }), TE.chain((file) => (0, function_1.pipe)(this.fileStorage.getSharedUrl(file.key), TE.map((sharedUrl) => {
            var _a, _b;
            return operationResponse.responseParser({
                name: file.metadata.name,
                url: sharedUrl.url,
                mime_type: (_a = file.metadata.contentType) !== null && _a !== void 0 ? _a : '',
                expires: (_b = sharedUrl.expires) !== null && _b !== void 0 ? _b : 0,
            });
        }))));
    }
    parseeBodyAsText(operationResponse) {
        const arrayBufferTE = BufferExtensions_1.BufferExtensions.readableToArrayBuffer(operationResponse.response.body);
        return (0, function_1.pipe)(arrayBufferTE, TE.chain((arrayBuffer) => {
            const deserializeBody = new TextDecoder().decode(arrayBuffer);
            return TE.right(operationResponse.responseParser(deserializeBody));
        }));
    }
}
exports.HttpOperationExecution = HttpOperationExecution;
